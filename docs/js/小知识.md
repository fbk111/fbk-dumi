# js的小知识
作者: fbk
时间：2022-12-16
地点：济南
>足够优秀再大方拥有


## 1.map函数
```js
let array=[1,2,3]
array.map(console.log)
```

`结果`
![](../img/2022-12-16/map结果.png)

## 2.防抖
### 1.防抖的作用：n秒以后再执行这个函数，如果重新触发，则重新计时
### 2.先上代码
```js
function resizeColor(){
    let r=Math.floor(Math.random()*255)
    let g=Math.floor(Math.random()*255)
    let b=Math.floor(Math.random()*255)
        window.addEventListener('resize', throttle(coloring, 2000))
}
document.addEventListener('resize',resizeColor)
```
这是没有控制防抖的代码，很明显，随着屏幕的缩放，屏幕的颜色也在随时改变
- solution
```js
    function resizeColor(){
    let r=Math.floor(Math.random()*255)
    let g=Math.floor(Math.random()*255)
    let b=Math.floor(Math.random()*255)
            document.body.style.background = `rgb(${r},${g},${b})`
}
function fangdou(func,delay){
    let timer;
    return function(){
        let args=arguments
        clearTimeout(timer)
        let context=this
        timer=setTimeout(()=>{
           func.apply(context,args)
        },delay)
    }
}
window.addEventListener('resize',fangdou(resizeColor,2000))
```

## 3.节流：n秒之内只能触发一次
```html
<body>
<input type="button" value="点击click"/>
<script>
document.querySelector('input').addEventListener('click',jieliu(saveMoney,2000))
function saveMoney(){
    console.log('我要省钱')
}
function jieliu(func,delay){
   let oldTime=Date.now()
   return function(...args){
    let newTime=Date.now()
    if(newTime>oldTime>=delay){
        fn.apply(null,args)
        oldTime=Date.now()
    }
   }
}
</script>
</body>
```

## 4.函数的柯里化
首先我们举一个代码例子
```js
//普通函数
function add(a,b){
    return a+b
}
//柯里化
function curryingAdd(x){
    return function(y){
        return  x+y
    }
}
```
- 通用的封装方法
```js
var currying=function(){
    var args=Array.property.splice.call()
}
```

## 5.js的闭包
### 1.百度解释：
闭包就是能够读取其他函数内部变量的函数。例如在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
直接上代码
```js
var a='全局变量'
function A(){
    var a='局部变量'
    B()
}
function B(){
    console.log(a)
}
A()
```
分析执行栈执行的结果
1.a，A，B进入全局上下文
2.当执行A，。a作为A的局部变量
3.B（）被推倒栈顶，但是作用域依然是全局，所以输出是`全局变量`
- 闭包的作用
```js
var a='全局变量'
function A(){ 
    var a='局部变量'
    return{
    B:function(){
        console.log(a)
    }
    }
}
var obj=A()
obj.B()
```
其实很显然，是用obj执行的B方法，B的作用域链当然是指向A的
## 6.sort排序
数字排序中
当function(x,y)得到的返回值小于0,x会被移动到y前面
当function(x,y)得到的返回值大于0，x会被移动到y后面
升序,return x-y
降序,return y-x
## 递归
今天再说一说递归吧，递归的应用场景可能在平常的时候不常见，但是许多算法包括竞赛很喜欢递归，不管是哪种语言，他们总有共同的递归处
- 都要确定递归的出口
- 方法的执行都是入栈和出栈的操作

以最经典的斐波那契数列，题目就是求出斐波那契的第n个数的数值
```js
function solution(n){
//首先要确定递归的出口
if(n===1||n===2) return 1
return solution(n-1)+solution(n-2)
}
```
当初写下这个代码还是存在疑问的，但是其实通过栈也就逐渐明白，无非就是方法的入栈，先进后出的原理，随着n不断地减小，他就会逐渐逼近栈的出口，finally，当n等于1或者2，就会出栈，n===1和n===2统一的拆分父类是什么，n===3，那么也就说n===3就是2,说到这里，我相信大家肯定可以明白了🐵

## js任务执行
- 同步任务
- 异步任务
  - 在ES5后，js引入了promise，这样不需要浏览器，js自身引擎就可以发起异步任务了
  - 宏任务是由浏览器，node发起的
    - setTimeout
    - 事件
    - 网络请求（ajax，fetch）
    - 事件
    - script
  - 微任务是由js引擎发起的
    - promise：promise本身是同步任务的，但是then和catch的回调函数是异步的
    - process.nextTick
    - async/await
    - Object.observe
### 执行顺序
1. 执行栈
2. 微任务队列
3. 宏任务队列
