import{_ as e,o as i,c as a,a as o}from"./app.1ab3fa21.js";const n="/assets/tongbuzuse.9677a354.png",l="/assets/tongbufeizuse.7baf5c1c.png",s="/assets/duolufuyong.9f40a919.png",t="/assets/duolufuyongselector.d28e6b85.png",r="/assets/yibu.d59949d6.png",c="/assets/zongjie.599b888d.png",k=JSON.parse('{"title":"IO模型详解","description":"","frontmatter":{},"headers":[{"level":2,"title":"常见的IO模型","slug":"常见的io模型","link":"#常见的io模型","children":[]},{"level":2,"title":"同步阻塞","slug":"同步阻塞","link":"#同步阻塞","children":[]},{"level":2,"title":"NIO (Non-blocking/New I/O)","slug":"nio-non-blocking-new-i-o","link":"#nio-non-blocking-new-i-o","children":[]},{"level":2,"title":"I/O多路复用","slug":"i-o多路复用","link":"#i-o多路复用","children":[]},{"level":2,"title":"AIO (Asynchronous I/O)","slug":"aio-asynchronous-i-o","link":"#aio-asynchronous-i-o","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"relativePath":"java/IO模型详解.md","lastUpdated":1673446306000}'),d={name:"java/IO模型详解.md"},h=o('<h1 id="io模型详解" tabindex="-1">IO模型详解 <a class="header-anchor" href="#io模型详解" aria-hidden="true">#</a></h1><p>作者: fbk 时间：2023-1-11 地点：济南</p><blockquote><p>足够优秀再大方拥有</p></blockquote><h2 id="常见的io模型" tabindex="-1">常见的IO模型 <a class="header-anchor" href="#常见的io模型" aria-hidden="true">#</a></h2><ul><li>同步阻塞I/O</li><li>同步非阻塞I/O</li><li>I/O多路复用</li><li>信号驱动I/O</li><li>异步I/O</li></ul><h2 id="同步阻塞" tabindex="-1">同步阻塞 <a class="header-anchor" href="#同步阻塞" aria-hidden="true">#</a></h2><p>在应用程序发起read调用，会一直阻塞，直到内核把数据拷贝到用户空间 <img src="'+n+'" alt=""> 在连接数量过高的情况下，传统的BIO是不行的</p><h2 id="nio-non-blocking-new-i-o" tabindex="-1">NIO (Non-blocking/New I/O) <a class="header-anchor" href="#nio-non-blocking-new-i-o" aria-hidden="true">#</a></h2><p>在java1.4引入，提供了<code>Channel</code>,<code>Selector</code>,<code>Buffer</code><img src="'+l+'" alt=""> 同步非阻塞进行轮询操作，避免了一直阻塞，但是在内核拷贝到用户空间，线程还是阻塞的</p><h2 id="i-o多路复用" tabindex="-1">I/O多路复用 <a class="header-anchor" href="#i-o多路复用" aria-hidden="true">#</a></h2><p><img src="'+s+'" alt=""> IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间 -&gt; 用户空间）还是阻塞的。目前支持 IO 多路复用的系统调用，有 select，epoll 等等。</p><ul><li>select 系统调用，目前几乎在所有的操作系统上都有支持。select 调用 ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。</li><li>epoll 调用 ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。</li></ul><p>IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。</p><p>Java 中的 NIO ，有一个非常重要的选择器 ( Selector ) 的概念，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><p><img src="'+t+'" alt=""></p><h2 id="aio-asynchronous-i-o" tabindex="-1">AIO (Asynchronous I/O) <a class="header-anchor" href="#aio-asynchronous-i-o" aria-hidden="true">#</a></h2><p>异步IO基于事件和回调机制实现的，就是应用操作之后就会返回，不会堵塞在那里，当内核准备完后会通知相应的线程进行后续操作 <img src="'+r+'" alt=""></p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-hidden="true">#</a></h2><p><img src="'+c+'" alt=""></p>',19),p=[h];function u(_,g,I,O,b,f){return i(),a("div",null,p)}const v=e(d,[["render",u]]);export{k as __pageData,v as default};
